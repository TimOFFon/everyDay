//=======================================================
//=================== Тип данных Symbol =================
//=======================================================

/**По спецификации, в качестве ключей для свойств объекта могут
 *  использоваться только строки или символы. */

//Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.

//Создаются новые символы с помощью функции Symbol():

let newObj = {
    a: 1,
    b: 2,
};

let id = Symbol();

newObj[id] = 'secret';
// console.log(newObj[id]); // 'secret'

function iteratorObj(obj) {
    for(let key in obj) {
        console.log(obj[key]);
    };
}

// iteratorObj(newObj); // 1, 2 forin не видит id

// console.log(newObj); // {a: 1, b: 2, Symbol(): 'secret'}



/**При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода: */

let newObj1 = {
    a: 1,
    b: 2,
};


let id1 = Symbol('id');// Создаём символ id с описанием (именем) "id

newObj1[id1] = 'secret1';

// console.log(newObj1); //{a: 1, b: 2, Symbol(id): 'secret1'}



/**Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет */

let newObj2 = {
    a: 1,
    b: 2,
};

let id11 = Symbol('id');
let id22 = Symbol('id');

// console.log(id11 == id22); // false

//=======================================================
//=== Символы не преобразуются автоматически в строки  ==
//=======================================================

/**Это – языковая «защита» от путаницы, ведь строки и символы – принципиально разные типы данных и не должны неконтролируемо преобразовываться друг в друга.
 */

let idA = Symbol('id');

// alert(idA); // TypeError: Cannot convert a Symbol value to a string

// alert(idA.toString());// 'Symbol(id)'

// Вариант 2 

// alert(idA.description); // 'id'


//=======================================================
//============ Символы в литеральном объекте  ==========
//=======================================================

let idF = Symbol('idF');

let user777 = {
    name: 'Vasya',
    [idF]: 123 // <----------- символы в литерале в квадратных скобках
};

/**Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id». */



/**А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства: */

let idO = Symbol('idO');
let objUser = {
    a: 1,
    [idO]: 123
};
let clonObj = Object.assign({}, objUser);

// console.log(clonObj); // {a: 1, Symbol(idO): 123}




//=======================================================
//================== Глобальные символы  ================
//=======================================================
//====================== Symbol.for();  ================
//=======================================================

/**Для чтения (или, при отсутствии, создания) символа из реестра
 *  используется вызов Symbol.for(key). 
 * 
 * Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый символ Symbol(key) и записывается в реестр под ключом key.*/


// читаем символ из глобального реестра и записываем его в переменную
let idUnic = Symbol.for('unicID');

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idUnicAgain = Symbol.for("unicID");

// проверяем -- это один и тот же символ
// console.log(idUnic === idUnicAgain);// true

//==================================================================
//Символы, содержащиеся в реестре, называются глобальными символами.
//===================================================================

//=======================================================
//====================== Symbol.keyFor  ================
//=======================================================

/**наоборот, принимает глобальный символ и возвращает его имя. */

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
//console.log( Symbol.keyFor(sym) ); // name
//console.log( Symbol.keyFor(sym2) ); // id

//Для не глобальных символов вернёт undefined.


//===================================================================
//====   для любых символов доступно свойство description ==========
//===================================================================

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

// console.log( Symbol.keyFor(globalSymbol) ); // name, глобальный символ
// console.log( Symbol.keyFor(localSymbol) ); // undefined для неглобального символа

// console.log( localSymbol.description ); // name


//==========================================================
//====================== Системные символы  ================
//==========================================================

//чтобы настраивать различные аспекты поведения объектов

/**
 * 
 *                  Symbol.unscopables
 *                  Symbol.toStringTag
 *                  Symbol.split
 *                  Symbol.species
 *                  Symbol.search 
 *                  Symbol.replace
 *                  Symbol.matchAll
 *                  Symbol.match        
 *                  Symbol.asyncIterator
 *                  Symbol.hasInstance
 *                  Symbol.isConcatSpreadable
 *                  Symbol.iterator
 *                  Symbol.toPrimitive
 *                  
 * 
 *     Symbol.toPrimitive - позволяет описать правила для объекта, согласно   *     которым он будет преобразовываться к примитиву
 * 
 *     Symbol.iterator для итераторов
 */

/** Object.getOwnPropertySymbols(obj) – с его помощью можно получить все свойства объекта с ключами-символами. */

/** метод Reflect.ownKeys(obj), который возвращает все ключи объекта, включая символьные. */
let idBB = Symbol('id');
let idA1 = Symbol.for('id1');
let idB1 = Symbol('id1');

let expObj1 = {
    a: 1,
    b: 2,
    ab: {
        ab: 1,
        bb: 2,
        [idBB]: 'idBB'
    },
    [idA1]: 'superMetod',
    [idB1]: 'idSimpleB'
};

let show = Object.getOwnPropertySymbols(expObj1);

console.log(show); // [Symbol(id1), Symbol(id1)]




let show2 = Reflect.ownKeys(expObj1);

console.log(show2); // ['a', 'b', 'ab', Symbol(id1), Symbol(id1)]
