// Тернарный оператор:
//-----------------------------------
//https://www.codewars.com/kata/56f3f6a82010832b02000f38/train/javascript

//Be Concise I - The Ternary Operator

/* Вам дана функция descriptionAge, которая принимает возраст параметра (который всегда будет положительным целым числом) и делает следующее:

Если возраст 12 лет или меньше, возвращается "Ты ребенок"
Если возраст от 13 до 17 (включительно), возвращается «Вы подросток».
Если возраст находится в диапазоне от 18 до 64 лет (включительно), возвращается «Вы взрослый».
Если возраст 65 лет или выше, возвращается "Вы пожилой человек"
Ваша задача максимально сократить код. Обратите внимание, что отправка данного кода не будет работать, поскольку существует ограничение на количество символов 137.

Я дам вам несколько советов:

Само название является подсказкой — если вы не знаете, что делать, всегда исследуйте любую терминологию в этом описании, о которой вы не слышали!
Тебе не кажется, что фраза «"You're a(n) <insert_something_here>"» часто повторяется? ;) Может, укоротим?
Пишите все в одну строку, \n и другие пробелы учитываются.
Что бы вы ни делали, не меняйте то, что делает функция. Удачи :) 

function describeAge(age) {
  if (age <= 12) {
    return "You're a(n) kid";
  } else if (age >= 13 && age <= 17) {
    return "You're a(n) teenager";
  } else if (age >= 18 && age <= 64) {
    return "You're a(n) adult";
  } else {
    return "You're a(n) elderly";
  }
}

*/
//let describeAge=age=>{let s="You're a(n) ";return age<=12?s+="kid":(age>=13&&age<= 17)?s+="teenager":(age>=18&&age<=64)?s+="adult":s+="elderly"}
//-------------------------------------------------

//https://www.codewars.com/kata/57089707fe2d01529f00024a/train/javascript

//Grasshopper - If/else syntax debug

/*
If/else syntax debug

Создавая игру, ваш партнер Грег решил создать функцию для проверки того, жив ли пользователь, которая называется checkAlive/CheckAlive/check_alive. К сожалению, Грег допустил несколько ошибок при создании функции.

checkAlive/CheckAlive/check_alive должны возвращать true, если здоровье игрока больше 0, или false, если оно равно 0 или ниже.

Функция получает один параметр здоровья, который всегда будет целым числом от -10 до 10.

function checkAlive (health) {
  if () {
    health < 0
    return false
  } else () {
    return true
  }
}
*/

let checkAlive = health => {
    return (health > 0) ? true : false
};

//---------------------------------------------------
/* Создай условное выражение из трёх условий:
Если "утро", то "рассвет";
Если "день", то "зенит";
Если "вечер", то "сумерки".
*/

let arrStr = [
    'Утро наступает, ... борется с ночью.',

    'День светлый и солнечный, уже жарко, а ещё даже не ....',

    'Вечер незаметно окутывал всё в ....'
];



function checkingWords(arr) {

    for (let i = 0; i < arr.length; i++) {
        let result =
            arr[i].match(/утро/gi) ? arr[i].replace(/(?<=\s)\.\.\./g, 'рассвет') :
            arr[i].match(/день/gi) ? arr[i].replace(/(?<=\s)\.\.\./g, 'зенит') :
            arr[i].match(/вечер/gi) ? arr[i].replace(/(?<=\s)\.\.\./g, 'сумерки') :
            arr;
        console.log(result);
    };
}

// checkingWords(arrStr);

///////////////////////////////////////////////////////////////////////////////////
// Оператор нулевого слияния ?? возвращает первый аргумент, если он не null/undefined, иначе второй.

// Сравнение разных типов приводит каждое из них к числу.
//При использовании математических операторов и других операторов сравнения < > <= >= Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN

/*isNaN()
Функция isNaN() определяет является ли литерал или переменная нечисловым значением (NaN) или нет. При работе с функцией необходимо проявлять осторожность так как она имеет свои особенности. В качестве альтернативы можно использовать метод Number.isNaN() из ECMAScript 6, или дополнительно проверять литерал или переменную на нечисловое значение при помощи typeof
*/

/*Number.isNaN()
Метод Number.isNaN() определяет, является ли переданное значение NaN. Это более надёжная версия оригинальной глобальной функции isNaN().
*/

/*Number.isFinite()
В отличии от глобальной функции isFinite(), этот метод принудительно не преобразует параметр в число. Это означает, что он возвращает true только для конечных значений числового типа.
*/

/*isFinite()
Глобальная isFinite() функция определяет, является ли переданное значение конечным числом. Если необходимо, параметр сначала преобразуется в число.
*/

//===========================================================================
/*
Циклические конструкции for и for/in предоставляют вам доступ к индексу в массиве, а не к фактическому элементу.
*/

const arrSearching = ['a', 'b', 'c'];

// for (let index = 0; index < arrSearching.length; ++index) {
//     console.log(arrSearching[index]);
// }
// for (let index in arrSearching) {
//     console.log(arrSearching[index]);
// }

/*
С двумя другими конструкциями, forEach() и for/of, вы сразу получаете доступ к самому элементу массива. С forEach() вы можете так же получить индекс массива index, с for/of индекс не доступен.
*/

// arrSearching.forEach((v, index) => console.log(v));

// for (const v of arrSearching) {
//     console.log(v);
// }

arrSearching.test = 'bad';


for (let i in arrSearching) {
    console.log(arrSearching[i]);
}